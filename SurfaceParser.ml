(* MotmotLite: A Motmotastic Linguistic Toy

   Copyright 2023 -- 2024, K.D.P.Ross <KDPRoss@gmail.com>

MotmotLite is released under the MotmotLite Licence with the
following terms:
- MotmotLite may be used for amusement and study.
- MotmotLite may be extended for similar purposes, provided
  that the changes involved in doing so are publicly
  released and licensed under the same terms.
- MotmotLite may only be used if you have joy and kindness
  in your thoughts.

   'When we agree about our hallucinations,
    we call that reality.' -- A.Seth

   'Be kind to yourself, and
    the world is your playground.'-KDP
 *)

(* Generated by           *
 *             CamlTrax   *
 *                     NG *
 *                        *
 * Copyright 2007-2024    *
 *             K.D.P.Ross *)

open Util
open ParserCombinators
open CommonParser

let checkEnd = CommonParser.(checkEnd surfaceKeywords)
let varPExt = varPExt >>= checkEnd
let varP = varP >>= checkEnd

let rec knd : Syntax.knd lazyParse =
  let core () =
    let karr =
      cache kndS <== txt "->" <=> cache knd >>> fun kk' -> Syntax.KArr kk'
    in
    karr ||| cache kndS
  in
  lazy (core ())

and kndS : Syntax.knd lazyParse =
  let core () =
    let kstar = txt "*" >>> const Syntax.KStar in
    let kbkt = parens (cache knd) in
    kstar ||| kbkt
  in
  lazy (core ())

let trailer = maybe (txt ",") >>> ignore

let rec typ : SurfaceSyntax.typ lazyParse =
  let core () =
    let tarr =
      cache typH <== txt "->" <=> cache typ >>> fun tt' ->
      SurfaceSyntax.TArr tt'
    in
    let tabs =
      parens (commaSepList1 varP <== txt ":" <=> cache knd)
      <== txt "=>" <=> cache typ
      >>> fun ((xs, k), t) -> SurfaceSyntax.TAbs (xs, k, t)
    in
    tarr ||| tabs ||| cache typH
  in
  lazy (core ())

and typH : SurfaceSyntax.typ lazyParse =
  let core () =
    let tapp =
      many1Spaces (cache typS)
      >>> fold1 ~f:(fun t t' -> SurfaceSyntax.TApp (t, t'))
    in
    tapp
  in
  lazy (core ())

and typS : SurfaceSyntax.typ lazyParse =
  let core () =
    let tvar = varP >>> fun x -> SurfaceSyntax.TVar x in
    let tany = txt "_" >>> fun _ -> SurfaceSyntax.TVar "_" in
    let tcval = atomP >>> fun c -> SurfaceSyntax.TCVal (c, []) in
    let ttpl =
      let proc = function
        | [ t ] -> SurfaceSyntax.TBrackets t
        | ts -> SurfaceSyntax.TTpl ts
      in
      parens (commaSepList1 (cache typ) <== trailer) >>> proc
    in
    let tlist =
      txt "[" ==> cache typ <== txt "]" >>> fun t ->
      SurfaceSyntax.TCVal ("List", [ t ])
    in
    let tarr =
      txt "(" ==> txt "->" <== txt ")" >>> fun _ ->
      SurfaceSyntax.TCVal ("->", [])
    in
    tarr ||| tlist ||| tvar ||| tany ||| tcval ||| ttpl
  in
  lazy (core ())

let negNumberQ s = Str.string_match (Str.regexp "^-[0-9]+[kmb]?$") s 0
let mixfixSpecs = Syntax.Mixfix.defaultSpecs

let numP : Q.t parse =
  regexp (Str.regexp "-?[0-9]+\\([.][0-9]+\\)?") >>> Q.of_string

let exp : SurfaceSyntax.exp lazyParse =
  let rec patExt : SurfaceSyntax.pat lazyParse =
    let core () =
      let pany =
        txt "_" ==> txt ":" ==> cache typ >>> fun t -> SurfaceSyntax.PAnyNoBkt t
      in
      let pvar =
        varPExt <== txt ":" <=> cache typ >>> fun xt ->
        SurfaceSyntax.PVarNoBkt xt
      in
      pany ||| pvar ||| cache patC
    in
    lazy (core ())
  and patC : SurfaceSyntax.pat lazyParse =
    let core () =
      let pconj =
        cache patE <== txt "and" <=> cache patC >>> fun (p, p') ->
        SurfaceSyntax.PConj (p, p')
      in
      pconj ||| cache patE
    in
    lazy (core ())
  and patE : SurfaceSyntax.pat lazyParse =
    let core () =
      let pcons =
        cache patH <== txt "::" <=> cache patE >>> fun (p, p') ->
        SurfaceSyntax.PListCons (p, p')
      in
      pcons ||| cache patH
    in
    lazy (core ())
  and patH : SurfaceSyntax.pat lazyParse =
    let core () =
      let pcsmp =
        atomP <=> many1Spaces (cache patS) >>> fun (c, ps) ->
        SurfaceSyntax.PCVal (c, [], ps)
      in
      let tapp =
        atomP <*= txt "{"
        <=> commaSepList1 (cache typ)
        <== txt "}"
        <=> many1Spaces (cache patS)
        >>> fun ((c, ts), ps) -> SurfaceSyntax.PCVal (c, ts, ps)
      in
      tapp ||| pcsmp ||| cache patS
    in
    lazy (core ())
  and patS : SurfaceSyntax.pat lazyParse =
    let core () =
      let pany =
        parens (txt "_" ==> txt ":" ==> cache typ) >>> fun t ->
        SurfaceSyntax.PAny t
      in
      let pvar =
        parens (varPExt <== txt ":" <=> cache typ) >>> fun xt ->
        SurfaceSyntax.PVar xt
      in
      let pcns = atomP >>> fun c -> SurfaceSyntax.PCVal (c, [], []) in
      let ptup =
        let proc = function
          | [ p ] -> SurfaceSyntax.PBrackets p
          | ps -> SurfaceSyntax.PTup ps
        in
        parens (commaSepList1 (cache patExt) <== trailer) >>> proc
      in
      let ppred =
        txt "{" =*> cache exp <*= txt "}" >>> fun e -> SurfaceSyntax.PPred e
      in
      let pexp = txt "`" =*> cache expS >>> fun e -> SurfaceSyntax.PEq e in
      let pwhen =
        txt "`{" ==> cache exp <== txt "}"
        <*> maybe (txt "{" ==> cache typ <== txt "}")
        >>> fun emt -> SurfaceSyntax.PWhen emt
      in
      let plist =
        txt "[" =!> commaSepList1 (cache patExt) <== trailer <== txt "]"
        >>> fun ps -> SurfaceSyntax.PList ps
      in
      let pnil =
        txt "[{" =!> cache typ <== txt "}]" >>> fun t -> SurfaceSyntax.PNil t
      in
      let tapp =
        atomP <*= txt "{" <!> commaSepList1 (cache typ) <== trailer <== txt "}"
        >>> fun (c, ts) -> SurfaceSyntax.PCVal (c, ts, [])
      in
      let pnum = numP >>> fun n -> SurfaceSyntax.PNum n in
      pnum ||| tapp ||| pnil ||| plist ||| pany ||| pvar ||| pcns ||| ppred
      ||| ptup ||| pwhen ||| pexp
    in
    lazy (core ())
  and exp : SurfaceSyntax.exp lazyParse =
    let core () =
      let ann =
        cache expB <== txt ":" <=> cache typ >>> fun et -> SurfaceSyntax.EAnn et
      in
      ann ||| cache expB
    in
    lazy (core ())
  and etabs =
    lazy
      ( parens (varP <== txt ":" <=> cache knd) <== txt "=>" <=> cache expB
      >>> fun ((x, k), e) -> SurfaceSyntax.ETAbs ([ x ], k, e) )
  and eabs =
    lazy
      ( repsep1 (cache patExt <== just ()) (txt "|" <== just ())
      <== txt "~" <!> cache expB
      >>> fun pse -> SurfaceSyntax.EAbs pse )
  and efun =
    lazy
      ( txt "fun" =!> many1Spaces (cache expT) >>> fun es ->
        SurfaceSyntax.EFun es )
  and expB : SurfaceSyntax.exp lazyParse =
    let core () =
      let bind = cache patExt <== txt "=" <!> cache expB <== just () in
      let ewhere =
        cache expM <== txt "where" <=> repsep1 bind (txt "|" <== just ())
        >>> fun ebs -> SurfaceSyntax.EWhere ebs
      in
      cache etabs ||| cache eabs ||| ewhere ||| cache expM
    in
    lazy (core ())
  and expM : SurfaceSyntax.exp lazyParse =
    let core () =
      let efcmp =
        cache expH <== txt "<+"
        <=> repsepK (cache expH <== just ()) (txt "<+" <== just ())
        >>> fun (e, es) -> SurfaceSyntax.EFcmp (e :: es)
      in
      let caseP =
        let deconNoBrack =
          repsepK (cache expH <== just ()) (txt "|" <== just ())
        in
        let deconBrack =
          parens (repsep1 (cache expH <== just ()) (txt "|" <== just ()))
        in
        let decon = deconBrack ||| deconNoBrack in
        txt "case" =!> decon <== txt "of" <=> many1Spaces (cache expT)
        >>> fun eses' -> SurfaceSyntax.ECaseOf eses'
      in
      efcmp ||| cache efun ||| caseP ||| cache expH
    in
    lazy (core ())
  and expH : SurfaceSyntax.exp lazyParse =
    let core () =
      let handleApp (es : SurfaceSyntax.exp list) : SurfaceSyntax.exp parse =
        match es &> ResolveApp.appTreesOfExps @> ResolveApp.resolveApps with
        | Some t ->
            let e = ResolveApp.expOfAppTree t in
            just e
        | None -> fail "Invalid application."
      in
      let eapp = many1Spaces (cache expT) >>= handleApp in
      let tapp =
        cache expT <*= txt "{" <!> commaSepList1 (cache typ) <!= txt "}"
        >>> fun ets -> SurfaceSyntax.ETAppMany ets
      in
      let lsec =
        txt "{" =!> cache typ <!= txt "}" <!> cache expT <=> cache expT
        >>> fun ((t, x), e) -> SurfaceSyntax.ELSec (t, x, e)
      in
      let rsec =
        cache expT <=> cache expT <!> (txt "{" =!> cache typ <!= txt "}")
        >>> fun ((e, x), t) -> SurfaceSyntax.ERSec (e, x, t)
      in
      let limp =
        txt "_" =!> cache expT <=> cache expT >>> fun (x, e) ->
        SurfaceSyntax.ELSecImp (x, e)
      in
      let rimp =
        cache expT <=> cache expT <!= txt "_" >>> fun (e, x) ->
        SurfaceSyntax.ERSecImp (e, x)
      in
      let lscb =
        txt "{" =!> cache typ <!= txt "}" <!> many1Spaces (cache expT)
        >>= fun (t, es) ->
        match es with
        | SurfaceSyntax.EVar x :: es ->
            handleApp es >>= fun e -> just SurfaceSyntax.(ELSec (t, EVar x, e))
        | _ -> fail "bad left section"
      in
      let rscb =
        many1Spaces (cache expT) <!= txt "{" <!> cache typ <!= txt "}"
        >>= fun (es, t) ->
        match List.rev es with
        | SurfaceSyntax.EVar x :: es ->
            let es = List.rev es in
            handleApp es >>= fun e -> just SurfaceSyntax.(ERSec (e, EVar x, t))
        | _ -> fail "bad right section"
      in
      let limb =
        txt "_" =!> many1Spaces (cache expT) >>= function
        | SurfaceSyntax.EVar x :: es ->
            handleApp es >>= fun e -> just SurfaceSyntax.(ELSecImp (EVar x, e))
        | _ -> fail "bad left section"
      in
      let rimb =
        many1Spaces (cache expT) <!= txt "_" >>= fun es ->
        match List.rev es with
        | SurfaceSyntax.EVar x :: es ->
            let es = List.rev es in
            handleApp es >>= fun e -> just SurfaceSyntax.(ERSecImp (e, EVar x))
        | _ -> fail "bad right section"
      in
      rimb ||| limb ||| rscb ||| lscb ||| limp ||| rimp ||| rsec ||| lsec
      ||| tapp ||| eapp
    in
    lazy (core ())
  and expT : SurfaceSyntax.exp lazyParse =
    let core () =
      let app =
        let proc = function
          | e, Some ts -> SurfaceSyntax.ETAppMany (e, ts)
          | e, None -> e
        in
        cache expS
        <*> maybe (txt "{" ==> commaSepList1 (cache typ) <== txt "}")
        >>> proc
      in
      app
    in
    lazy (core ())
  and expS : SurfaceSyntax.exp lazyParse =
    let core () =
      let evar =
        varPExt >>= function
        | "_" -> fail "invalid variable"
        | s when negNumberQ s -> fail "that's a number"
        | x -> just (SurfaceSyntax.EVar x)
      in
      let ecval = atomP >>> fun c -> SurfaceSyntax.ECons c in
      let etup =
        let proc = function
          | [ e ] -> SurfaceSyntax.EBrackets e
          | es -> SurfaceSyntax.ETup es
        in
        parens (commaSepList1 (cache exp) <== trailer) >>> proc
      in
      let enil =
        txt "[{" =!> cache typ <== txt "}]" >>> fun t -> SurfaceSyntax.ENil t
      in
      let elist =
        txt "[" =!> commaSepList1 (cache exp) <== trailer <== txt "]"
        >>> fun es -> SurfaceSyntax.EListLit es
      in
      let emap =
        txt "{m" ||| txt "{"
        =!> commaSepList1 (cache expT <== txt "|->" <=> cache exp)
        <== trailer <== txt "}"
        >>> fun ps -> SurfaceSyntax.EMapLit ps
      in
      let enum = numP >>> fun n -> SurfaceSyntax.ENum n in
      emap ||| enil ||| elist ||| evar ||| ecval ||| etup ||| enum
    in
    lazy (core ())
  in
  exp

let tlExp s =
  let tlExp = cache exp >>> fun e -> TopLevelSyntax.TLExp e in
  let tlBind =
    varPExt <== txt ":" <=> cache typ <== txt "=" <=> cache exp
    >>> fun ((x, t), e) -> TopLevelSyntax.TLBind (x, t, e)
  in
  wrapParser (spaces =*> (tlBind ||| tlExp) <*= spaces <*= eof) s

let knd s = wrapParser (spaces =*> cache knd <*= spaces <*= eof) s
let typ s = wrapParser (spaces =*> cache typ <*= spaces <*= eof) s
let expExt s = wrapParser (spaces =*> cache exp <*= spaces <*= eof) s
