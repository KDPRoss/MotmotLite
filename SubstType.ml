(* MotmotLite: A Motmotastic Linguistic Toy

   Copyright 2023 -- 2025, K.D.P.Ross <KDPRoss@gmail.com>

MotmotLite is released under the MotmotLite Licence with the
following terms:
- MotmotLite may be used for amusement and study.
- MotmotLite may be extended for similar purposes, provided
  that the changes involved in doing so are publicly
  released and licensed under the same terms.
- MotmotLite may only be used if you have joy and kindness
  in your thoughts.

   'When we agree about our hallucinations,
    we call that reality.' -- A.Seth

   'Be kind to yourself, and
    the world is your playground.'-KDP
 *)

(* Generated by           *
 *             CamlTrax   *
 *                     NG *
 *                        *
 * Copyright 2007-2025    *
 *             K.D.P.Ross *)

open Util
open Syntax
module PolyHash = Core.Hashtbl.Poly

let ( ++ ) = StringSet.union

let concatSets : StringSet.t list -> StringSet.t =
  List.fold_left ~init:StringSet.empty ~f:( ++ )

let fail : 'a. string -> 'a =
 fun msg ->
  let _ = print_endline msg in
  raise Typing.TypeError

let rec expFreeVars : exp -> StringSet.t = function
  | EVar _ | ENum _ -> StringSet.empty
  | ETAbs (x, _, e) ->
      let xs = expFreeVars e in
      StringSet.remove xs x
  | EAbs (ps, e) ->
      let xsPs = ps &> List.map ~f:patFreeVars @> concatSets in
      let xsE = expFreeVars e in
      xsPs ++ xsE
  | ETApp (e, t) ->
      let xsE = expFreeVars e in
      let xsT = typFreeVars t in
      xsE ++ xsT
  | EApp (e1, e2) ->
      let xsE1 = expFreeVars e1 in
      let xsE2 = expFreeVars e2 in
      xsE1 ++ xsE2
  | ETup es | EFcmp es | ECVal (_, es) | EList es ->
      es &> List.map ~f:expFreeVars @> concatSets
  | ELet (bs, e) ->
      let xsBs =
        let one (p, e) =
          let xsP = patFreeVars p in
          let xsE = expFreeVars e in
          xsP ++ xsE
        in
        bs &> List.map ~f:one @> concatSets
      in
      let xsE = expFreeVars e in
      xsBs ++ xsE
  | (ECls _ | EDely _ | ELazy _ | EMap _ | ENatF _) as e ->
      let s = CoreLineariser.showExp e in
      fail
        ("Cannot calculate free type vars for nonsyntactically-denotable \
          expression: " -- s -- ".")

and patFreeVars : pat -> StringSet.t = function
  | PAny t | PVar (_, t) -> typFreeVars t
  | PCVal (_, ts, ps) ->
      let xsTs = ts &> List.map ~f:typFreeVars @> concatSets in
      let xsPs = ps &> List.map ~f:patFreeVars @> concatSets in
      xsTs ++ xsPs
  | PTup ps -> ps &> List.map ~f:patFreeVars @> concatSets
  | PConj (p1, p2) ->
      let xsP1 = patFreeVars p1 in
      let xsP2 = patFreeVars p2 in
      xsP1 ++ xsP2
  | PPred e -> expFreeVars e
  | PWhen (e, tM) ->
      let xsE = expFreeVars e in
      let xsT =
        match tM with Some t -> typFreeVars t | None -> StringSet.empty
      in
      xsE ++ xsT

and typFreeVars : typ -> StringSet.t = function
  | TVar x -> StringSet.singleton x
  | TAbs (x, _, t) ->
      let xsT = typFreeVars t in
      StringSet.remove xsT x
  | TCVal (_, ts) | TTpl ts -> ts &> List.map ~f:typFreeVars @> concatSets
  | TArr (t1, t2) | TApp (t1, t2) ->
      let xsT1 = typFreeVars t1 in
      let xsT2 = typFreeVars t2 in
      xsT1 ++ xsT2

let localGensymMap : (string, int) PolyHash.t = PolyHash.create ()

let freshVar (base : string) : string =
  match PolyHash.find localGensymMap base with
  | None ->
      let _ = PolyHash.set ~key:base ~data:2 localGensymMap in
      base
  | Some i ->
      let _ = PolyHash.set ~key:base ~data:(i + 1) localGensymMap in
      base -- "/" -- string_of_int i

let rec expSubstTyp (x : string) (t : typ) : exp -> exp =
  let xsT = typFreeVars t in
  let rec core : exp -> exp = function
    | (EVar _ | ENum _) as e -> e
    | ETAbs (y, _, _) as e when y = x -> e
    | ETAbs (y, k, e) ->
        if StringSet.mem xsT y then
          let y' = freshVar y in
          let e' = expSubstTyp y (TVar y') e in
          core (ETAbs (y', k, e'))
        else
          let e' = core e in
          ETAbs (y, k, e')
    | EAbs (ps, e) ->
        let ps' = List.map ~f:(patSubstTyp x t) ps in
        let e' = core e in
        EAbs (ps', e')
    | ETApp (e, u) ->
        let e' = core e in
        let u' = typSubstTyp x t u in
        ETApp (e', u')
    | EApp (e1, e2) ->
        let e1' = core e1 in
        let e2' = core e2 in
        EApp (e1', e2')
    | ETup es ->
        let es' = List.map ~f:core es in
        ETup es'
    | EFcmp es ->
        let es' = List.map ~f:core es in
        EFcmp es'
    | EList es ->
        let es' = List.map ~f:core es in
        EList es'
    | ECVal (c, es) ->
        let es' = List.map ~f:core es in
        ECVal (c, es')
    | ELet (bs, e) ->
        let bs' =
          let one (p, e) =
            let p' = patSubstTyp x t p in
            let e' = core e in
            (p', e')
          in
          List.map ~f:one bs
        in
        let e' = core e in
        ELet (bs', e')
    | (ECls _ | EDely _ | ELazy _ | EMap _ | ENatF _) as e ->
        let s = CoreLineariser.showExp e in
        fail
          ("Cannot substitute type in nonsyntactically-denotable expression: "
         -- s -- ".")
  in
  core

and patSubstTyp (x : string) (t : typ) : pat -> pat =
 (function
 | PAny u ->
     let u' = typSubstTyp x t u in
     PAny u'
 | PVar (y, u) ->
     let u' = typSubstTyp x t u in
     PVar (y, u')
 | PCVal (c, ts, ps) ->
     let ts' = List.map ~f:(typSubstTyp x t) ts in
     let ps' = List.map ~f:(patSubstTyp x t) ps in
     PCVal (c, ts', ps')
 | PTup ps ->
     let ps' = List.map ~f:(patSubstTyp x t) ps in
     PTup ps'
 | PConj (p1, p2) ->
     let p1' = patSubstTyp x t p1 in
     let p2' = patSubstTyp x t p2 in
     PConj (p1', p2')
 | PPred e ->
     let e' = expSubstTyp x t e in
     PPred e'
 | PWhen (e, tM) ->
     let e' = expSubstTyp x t e in
     let tM' =
       match tM with
       | Some u ->
           let u' = typSubstTyp x t u in
           Some u'
       | None -> None
     in
     PWhen (e', tM'))

and typSubstTyp (x : string) (t : typ) : typ -> typ =
  let xsT = typFreeVars t in
  let rec core : typ -> typ = function
    | TVar y when y = x -> t
    | TVar _ as u -> u
    | TAbs (y, _, _) as t when y = x -> t
    | TAbs (y, k, u) ->
        if StringSet.mem xsT y then
          let y' = freshVar y in
          let u' = typSubstTyp y (TVar y') u in
          core (TAbs (y', k, u'))
        else
          let u' = core u in
          TAbs (y, k, u')
    | TCVal (c, ts) ->
        let ts' = List.map ~f:core ts in
        TCVal (c, ts')
    | TTpl ts ->
        let ts' = List.map ~f:core ts in
        TTpl ts'
    | TArr (t1, t2) ->
        let t1' = core t1 in
        let t2' = core t2 in
        TArr (t1', t2')
    | TApp (t1, t2) ->
        let t1' = core t1 in
        let t2' = core t2 in
        TApp (t1', t2')
  in
  core

let rec expFreshTyp : exp -> exp = function
  | (EVar _ | ENum _) as e -> e
  | ETAbs (x, k, e) ->
      let x' = freshVar x in
      let e' = e &> expSubstTyp x (TVar x') @> expFreshTyp in
      ETAbs (x', k, e')
  | EAbs (ps, e) ->
      let ps' = List.map ~f:patFreshTyp ps in
      let e' = expFreshTyp e in
      EAbs (ps', e')
  | ETApp (e, t) ->
      let e' = expFreshTyp e in
      let t' = typFreshTyp t in
      ETApp (e', t')
  | EApp (e1, e2) ->
      let e1' = expFreshTyp e1 in
      let e2' = expFreshTyp e2 in
      EApp (e1', e2')
  | ETup es ->
      let es' = List.map ~f:expFreshTyp es in
      ETup es'
  | EFcmp es ->
      let es' = List.map ~f:expFreshTyp es in
      EFcmp es'
  | ECVal (c, es) ->
      let es' = List.map ~f:expFreshTyp es in
      ECVal (c, es')
  | ELet (bs, e) ->
      let bs' =
        let one (p, e) =
          let p' = patFreshTyp p in
          let e' = expFreshTyp e in
          (p', e')
        in
        List.map ~f:one bs
      in
      let e' = expFreshTyp e in
      ELet (bs', e')
  | EList es ->
      let es' = List.map ~f:expFreshTyp es in
      EList es'
  | (ECls _ | EDely _ | ELazy _ | EMap _ | ENatF _) as e ->
      let s = CoreLineariser.showExp e in
      fail
        ("Cannot freshen type vars for nonsyntactically-denotable expression: "
       -- s -- ".")

and patFreshTyp : pat -> pat = function
  | PAny t ->
      let t' = typFreshTyp t in
      PAny t'
  | PVar (x, t) ->
      let t' = typFreshTyp t in
      PVar (x, t')
  | PCVal (c, ts, ps) ->
      let ts' = List.map ~f:typFreshTyp ts in
      let ps' = List.map ~f:patFreshTyp ps in
      PCVal (c, ts', ps')
  | PTup ps ->
      let ps' = List.map ~f:patFreshTyp ps in
      PTup ps'
  | PConj (p1, p2) ->
      let p1' = patFreshTyp p1 in
      let p2' = patFreshTyp p2 in
      PConj (p1', p2')
  | PPred e ->
      let e' = expFreshTyp e in
      PPred e'
  | PWhen (e, mT) ->
      let e' = expFreshTyp e in
      let mT' =
        match mT with
        | Some t ->
            let t' = typFreshTyp t in
            Some t'
        | None -> None
      in
      PWhen (e', mT')

and typFreshTyp : typ -> typ = function
  | TVar _ as t -> t
  | TAbs (x, k, t) ->
      let x' = freshVar x in
      let t' = t &> typSubstTyp x (TVar x') @> typFreshTyp in
      TAbs (x', k, t')
  | TCVal (c, ts) ->
      let ts' = List.map ~f:typFreshTyp ts in
      TCVal (c, ts')
  | TArr (t1, t2) ->
      let t1' = typFreshTyp t1 in
      let t2' = typFreshTyp t2 in
      TArr (t1', t2')
  | TApp (t1, t2) ->
      let t1' = typFreshTyp t1 in
      let t2' = typFreshTyp t2 in
      TApp (t1', t2')
  | TTpl ts ->
      let ts' = List.map ~f:typFreshTyp ts in
      TTpl ts'

let expFreshTyp (e : exp) : exp =
  let _ = PolyHash.clear localGensymMap in
  expFreshTyp e
